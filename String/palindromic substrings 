
> Given a string, count (or print) all substrings that are palindromes.



A string of length n has O(n²) substrings, so the best possible solution is O(n²) time.

There are two common O(n²) approaches:


---

1. Expand Around Center (Most Common, Easy to Code)

A palindrome mirrors around its center.

There are 2n-1 possible centers (each character and gap between characters).

Expand from each center while the substring is palindrome.


Java Implementation:

public class PalindromicSubstrings {
    public static int countPalindromicSubstrings(String s) {
        int n = s.length();
        int count = 0;

        for (int center = 0; center < 2 * n - 1; center++) {
            int left = center / 2;
            int right = left + center % 2;

            while (left >= 0 && right < n && s.charAt(left) == s.charAt(right)) {
                count++;
                left--;
                right++;
            }
        }
        return count;
    }

    public static void main(String[] args) {
        String s = "aaa";
        System.out.println(countPalindromicSubstrings(s)); // 6 ("a","a","a","aa","aa","aaa")
    }
}

⏱ Complexity:

Time: O(n²) (each expansion takes up to O(n), and we have 2n centers).

Space: O(1)



---

2. Dynamic Programming (DP Table)

dp[i][j] = true if substring s[i..j] is palindrome.

Fill table for increasing substring lengths.



public class PalindromicSubstringsDP {
    public static int countPalindromicSubstrings(String s) {
        int n = s.length();
        boolean[][] dp = new boolean[n][n];
        int count = 0;

        for (int len = 1; len <= n; len++) {
            for (int i = 0; i + len - 1 < n; i++) {
                int j = i + len - 1;
                if (s.charAt(i) == s.charAt(j)) {
                    if (len <= 2 || dp[i + 1][j - 1]) {
                        dp[i][j] = true;
                        count++;
                    }
                }
            }
        }
        return count;
    }

    public static void main(String[] args) {
        String s = "aba";
        System.out.println(countPalindromicSubstrings(s)); // 4 ("a","b","a","aba")
    }
}

⏱ Complexity:

Time: O(n²)

Space: O(n²)



---

✅ Recommendation:
Use Expand Around Center if you just need to count palindromic substrings (less memory).
Use DP if you also need to reconstruct/store the substrings themselves.
